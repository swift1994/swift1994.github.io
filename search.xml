<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解ArrayList]]></title>
    <url>%2FJava%2F2017%2F09%2F05%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ArrayList.html</url>
    <content type="text"><![CDATA[ArrayList概述 ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。 每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。 注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。 ArrayList的实现 对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码 底层使用数组实现： Java代码 private transient Object[] elementData; 构造方法： ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。 Java代码 1. public ArrayList() { 2. this(10); 3. } 4. 5. public ArrayList(int initialCapacity) { 6. super(); 7. if (initialCapacity &lt; 0) 8. throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); 9. this.elementData = new Object[initialCapacity]; 10. } 11. 12. public ArrayList(Collection&lt;? extends E&gt; c) { 13. elementData = c.toArray(); 14. size = elementData.length; 15. // c.toArray might (incorrectly) not return Object[] (see 6260652) 16. if (elementData.getClass() != Object[].class) 17. elementData = Arrays.copyOf(elementData, size, Object[].class); 18. } 存储： ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解： Java代码 1. // 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。 2. public E set(int index, E element) { 3. RangeCheck(index); 4. 5. E oldValue = (E) elementData[index]; 6. elementData[index] = element; 7. return oldValue; 8. } Java代码 1. // 将指定的元素添加到此列表的尾部。 2. public boolean add(E e) { 3. ensureCapacity(size + 1); 4. elementData[size++] = e; 5. return true; 6. } Java代码 1. // 将指定的元素插入此列表中的指定位置。 2. // 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。 3. public void add(int index, E element) { 4. if (index &gt; size || index &lt; 0) 5. throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size); 6. // 如果数组长度不足，将进行扩容。 7. ensureCapacity(size+1); // Increments modCount!! 8. // 将 elementData中从Index位置开始、长度为size-index的元素， 9. // 拷贝到从下标为index+1位置开始的新的elementData数组中 10. // 即将当前位于该位置的元素以及所有后续元素右移一个位置。 11. System.arraycopy(elementData, index, elementData, index + 1, size - index); 12. elementData[index] = element; 13. size++; 14. } Java代码 1. // 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。 2. public boolean addAll(Collection&lt;? extends E&gt; c) { 3. Object[] a = c.toArray(); 4. int numNew = a.length; 5. ensureCapacity(size + numNew); // Increments modCount 6. System.arraycopy(a, 0, elementData, size, numNew); 7. size += numNew; 8. return numNew != 0; 9. } Java代码 1. // 从指定的位置开始，将指定collection中的所有元素插入到此列表中。 2. public boolean addAll(int index, Collection&lt;? extends E&gt; c) { 3. if (index &gt; size || index &lt; 0) 4. throw new IndexOutOfBoundsException( 5. &quot;Index: &quot; + index + &quot;, Size: &quot; + size); 6. 7. Object[] a = c.toArray(); 8. int numNew = a.length; 9. ensureCapacity(size + numNew); // Increments modCount 10. 11. int numMoved = size - index; 12. if (numMoved &gt; 0) 13. System.arraycopy(elementData, index, elementData, index + numNew, numMoved); 14. 15. System.arraycopy(a, 0, elementData, index, numNew); 16. size += numNew; 17. return numNew != 0; 18. } 4) 读取： Java代码 1. // 返回此列表中指定位置上的元素。 2. public E get(int index) { 3. RangeCheck(index); 4. 5. return (E) elementData[index]; 6. } 删除： ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：Java代码 1. // 移除此列表中指定位置上的元素。 2. public E remove(int index) { 3. RangeCheck(index); 4. 5. modCount++; 6. E oldValue = (E) elementData[index]; 7. 8. int numMoved = size - index - 1; 9. if (numMoved &gt; 0) 10. System.arraycopy(elementData, index+1, elementData, index, numMoved); 11. elementData[--size] = null; // Let gc do its work 12. 13. return oldValue; 14. } Java代码 1. // 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。 2. public boolean remove(Object o) { 3. // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。 4. if (o == null) { 5. for (int index = 0; index &lt; size; index++) 6. if (elementData[index] == null) { 7. // 类似remove(int index)，移除列表中指定位置上的元素。 8. fastRemove(index); 9. return true; 10. } 11. } else { 12. for (int index = 0; index &lt; size; index++) 13. if (o.equals(elementData[index])) { 14. fastRemove(index); 15. return true; 16. } 17. } 18. return false; 19. } 注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。 调整数组容量：从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。 Java代码 public void ensureCapacity(int minCapacity) { Count++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } } 从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。 ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：Java代码 1. public void trimToSize() { 2. modCount++; 3. int oldCapacity = elementData.length; 4. if (size &lt; oldCapacity) { 5. elementData = Arrays.copyOf(elementData, size); 6. } 7. } Fail-Fast机制：ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考我之前的文章深入Java集合学习系列：HashMap的实现原理 中的Fail-Fast机制。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的性能和伸缩性优化]]></title>
    <url>%2FMySQL%2F2017%2F08%2F01%2FMySQL%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E4%BC%B8%E7%BC%A9%E6%80%A7%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[1、选择 InnoDB 作为存储引擎 大型产品的数据库对于可靠性和并发性的要求较高，InnoDB 作为默认的 MySQL 存储引擎，相对于 MyISAM 来说是个更佳的选择。 2、优化数据库结构 组织数据库的 schema、表和字段以降低 I/O 的开销，将相关项保存在一起，并提前规划，以便随着数据量的增长，性能可以保持较高的水平。 设计数据表应尽量使其占用的空间最小化，表的主键应尽可能短。 对于 InnoDB 表，主键所在的列在每个辅助索引条目中都是可复制的，因此如果有很多辅助索引，那么一个短的主键可以节省大量空间。 仅创建你需要改进查询性能的索引。索引有助于检索，但是会增加插入和更新操作的执行时间。 3、InnoDB 的 Change Buffering 特性 InnoDB 提供了 change buffering 的配置，可减少维护辅助索引所需的磁盘 I/O。大规模的数据库可能会遇到大量的表操作和大量的 I/O，以保证辅助索引保持最新。当相关页面不在缓冲池里面时，InnoDB 的 change buffer 将会更改缓存到辅助索引条目，从而避免因不能立即从磁盘读取页面而导致耗时的 I/O 操作。当页面被加载到缓冲池时，缓冲的更改将被合并，更新的页面之后会刷新到磁盘。这样做可提高性能，适用于 MySQL 5.5 及更高版本。 4、InnoDB 页面压缩 InnoDB 支持对表进行页面级的压缩。当写入数据页的时候，会有特定的压缩算法对其进行压缩。压缩后的数据会写入磁盘，其打孔机制会释放页面末尾的空块。如果压缩失败，数据会按原样写入。表和索引都会被压缩，因为索引通常是数据库总大小中占比很大的一部分，压缩可以显著节约内存，I/O 或处理时间，这样就达到了提高性能和伸缩性的目的。它还可以减少内存和磁盘之间传输的数据量。MySQL 5.1 及更高版本支持该功能。 注意，页面压缩并不能支持共享表空间中的表。共享表空间包括系统表空间、临时表空间和常规表空间。 5、使用批量数据导入在主键上使用已排序的数据源进行批量数据的导入可加快数据插入的过程。否则，可能需要在其他行之间插入行以维护排序，这会导致磁盘 I/O 变高，进而影响性能，增加页的拆分。关闭自动提交的模式也是有好处的，因为它会为每个插入执行日志刷新到磁盘。在批量插入期间临时转移唯一键和外键检查也可显著降低磁盘 I/O。对于新建的表，最好的做法是在批量导入后创建外键/唯一键约束。 6、SQL 语句优化 为了提升查询的速度，可以为 WHERE 字句中使用的列添加索引。此外，不要将主键索引用于太多或太长的列，因为这些列值在辅助索引进行复制的时候会增加读取所需要的 I/O 资源并占用缓存。 如果索引包含了不必要的数据，通过 I/O 读取这些数据并进行缓存就会减弱服务器的性能和伸缩性。也不要为不必要的列使用唯一键索引，因为它会禁用 change buffering。应该使用常规索引代替。 减少和隔离需要耗费大量时间的函数调用。 尽可能的减少查询中的全表扫描次数。 调整缓存区域的大小和属性，比如 InnoDB 缓冲池，MySQL 查询缓存等，这样会通过从内存而非从硬盘获取数据而让重复的查询变得更快。 7、优化存储结构 对于大型的表，或者包含大量重复文本或数值数据的表，应该考虑使用 COMPRESSED(压缩的) 行格式。这样只需要较少的 I/O 就可以把数据取到缓冲池，或执行全表扫描。 一旦你的数据达到稳定的大小，或者增长的表增加了几十或几百兆字节，就应该考虑使用 OPTIMIZE TABLE 语句重新组织表并压缩浪费的空间。对重新组织后的表进行全表扫描所需要的 I/O 会更少。 8、优化 InnoDB 磁盘 I/O 增加 InnoDB 缓冲池大小可以让查询从缓冲池访问而不是通过磁盘 I/O 访问。通过调整系统变量 innodb_flush_method 来调整清除缓冲的指标使其达到最佳水平。 使用其它存储设备配置 RAID 9、MySQL 的内存分配 在为 MySQL 分配足够的内存之前，请考虑不同领域对 MySQL 的内存需求。 要考虑的关键领域是：并发连接 —— 对于大量并发连接，排序和临时表将需要大量内存。在撰写本文时，对于处理 3000+ 并发连接的数据库，16GB 到 32GB的 RAM 是足够的。 内存碎片可以消耗大约 10％ 或更多的内存。像 innodb_buffer_pool_size、key_buffer_size、query_cache_size 等缓存和缓冲区要消耗大约 80％ 的已分配内存。 10、日常维护 定期检查慢的查询日志并优化查询机制以有效使用缓存来减少磁盘 I/O。优化它们，以扫描最少的行数，而不是进行全表扫描。 其他可以帮助 DBA 检查和分析性能的日志包括：错误日志、常规查询日志、二进制日志、DDL日志（元数据日志）。 定期刷新缓存和缓冲区以降低碎片化。使用 OPTIMIZE TABLE 语句重新组织表并压缩任何可能被浪费的空间。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centOS环境搭建（一）]]></title>
    <url>%2FLinux%2F2017%2F07%2F31%2Flinux%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[阿里云ECS服务器,centos6.5安装jdk，mysql，tomcat现在很多博客上都有很多莫名的错误，我试着总结以下吧，希望减少时间的浪费，说实话我搭建了1天多才完全弄好，原因就是很多文档博客都不缜密，会出现很多错 前提下载安装xshell（具体如何是使用xshell请自行Google）和xftp 1 部署jdk查看系统是否安装了jdk [root@localhost ~]# java -version或者 [root@localhost ~]#rpm -qa |grep java 出现或者不出现以下内容： java version “1.7.0_24”OpenJDK Runtime Environment (build 1.7.0_24-b18)OpenJDK HotSpot(TM) Client VM (build 24.45-b08, mixed mode, sharing) 进一步查看JDK信息：[root@localhost ~]# rpm -qa | grep javatzdata-java-2012c-1.el6.noarchjava-1.7.0-openjdk-1.7.0.45-1.45.1.11.1.el6.x86_64 卸载OpenJDK，执行以下操作：[root@localhost ~]# rpm -e –nodeps tzdata-java-2012c-1.el6.noarch（解压jdk）[root@localhost ~]# rpm -e –nodeps java-1.7.0-openjdk-1.7.0.45-1.45.1.11.1.el6.x86_64 若出现以上以上情况，按照以上步骤操作完后，用xftp上传jdk-7-linux-i586.rpm或者jdk-8u25-linux-x64.tar.gz（具体jdk版本看你自己选择，在Oracle官网上下载 ）到xftp上的/usr/local 2 安装jdk（JDK默认安装在/usr/java中）：[root@localhost ~]#cd /usr/local (cd 空格后路径是你刚刚上传到xftp的路径，不要搞错了，我上是传到/usr/local，这一点很多博客文档都没说清楚，导致很多初学者会具体操作时出错)[root@localhost ckb]# rpm -ivh jdk-7-linux-i586.rpm或者[root@localhost ckb]#tar –zxvf jdk-8u25-linux-x64.tar.gz 3 验证安装执行以下操作，查看信息是否正常： [root@localhost bin]# java [root@localhost bin]# javac [root@localhost bin]# java -version java version “1.7.0_45”Java(TM) SE Runtime Environment (build 1.7.0_45-b18)Java HotSpot(TM) Client VM (build 24.45-b08, mixed mode, sharing) 4 配置环境变量我的机器安装完jdk-7-linux-i586.rpm后不用配置环境变量也可以正常执行javac、java –version操作，因此我没有进行JDK环境变量的配置。 但是为了以后的不适之需，这里还是记录一下怎么进行配置，操作如下：修改系统环境变量文件vi + /etc/profile执行之后 按”i”建，INSERT出现表示可以编辑向文件里面追加以下内容： 在光标处添加JAVA_HOME=/usr/java/jdk1.7.0_45 JRE_HOME=/usr/java/jdk1.7.0_45/jre PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin CLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH（然后按Esc退出，”:”符+ wq保存并退出） 使修改生效[root@localhost ~]# source /etc/profile（使修改立即生效） [root@localhost ~]# echo $PATH（查看PATH值） 查看系统环境状态 [root@localhost ~]# echo $PATH/usr/lib/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/java/jdk1.7.0_45/bin:/usr/java/jdk1.7.0_45/jre/bin:/home/ckb/bin 二、部署tomcat(与配置jdk类似)在tomcat官网上下载 apache-tomcat-8.0.15.tar.gz并上传到/usr/local [root@localhost ~]#cd /usr/local [root@localhost local]#tar –zxvf apache-tomcat-8.0.15.tar.gz 初始化配置：[root@localhost ~]#vi catalina.sh//设置环境变量 末行添加：JAVA_HOME=/usr/javaCATALINA_HOME=/usr/local/apache-tomcat-8.0.15export JAVA_HOME PATH（然后按Esc退出，”:”符+ wq保存并退出） 启动tomcat进入tomcat/bin目录 [root@localhost ~]#cd /usr/local/apache-tomcat-8.0.15/lib [root@localhost bin] # ./startup.sh[root@localhost bin] # ./shutdown.sh //关闭tomcat 启动之后就可以在浏览器输入你的公网ip:8080（tomcat默认端口），看到tomcat页面。 三 配置mysql（我的这里参考了http://blog.csdn.net/sapce_fish/article/details/51619830?locationNum=12&amp;fps=1这篇博客，版本为mysql.x86_64 5.1.73-7.el6，当然你也可以安装其他版本） 安装mysql；==特别注意==：网上很多安装mysql的文章，都是不行的！！！！ #我喜欢在home目录操作命令cd /home #查看所有以mysql开头的软件 yum list mysql* #安装mysql yum install mysql-server* -y #启动mysql /etc/init.d/mysqld start #设定mysql自动启动，我亲自重启了ECS，确实ok chkconfig mysqld on #复制mysql的配置文件到etc目录，提示是否覆盖，选择ycp /usr/share/mysql/my-medium.cnf /etc/my.cnf #重新设定mysql密码，默认密码是【空】，输入新密码，注意提问，是否删除匿名账户？【y】 是否禁止远程登录？【n】是否移除test数据库?【y】是否重载权限文件【y】mysql_secure_installation #重启mysql，此时用本机Navicat Premium还是连不上mysql的！/etc/init.d/mysqld restart #用命令访问mysqlmysql -u root -p #使用mysql数据库use mysql; #查询当前用户情况，显示有3条记录，127.0.0.1；localhost；izxxxxxxxdz；其中最后这个是ECS主机名 select host, user from user; #把localhost这条记录的host改为 %； 意思是root可以由任何主机登录mysql，网上很多写法，都没有and host=’localhost’这个条件，经常报错。update user set host = ‘%’ where user = ‘root’ and host=’localhost’; #再次查询，可以看到host有3个；%；127.0.0.1；izxxxxxxxdz；其实user表的主键是user字段和host字段的联合主键。select host, user from user; #保险起见，重启mysql，Navicat Premium连接正常！万岁！/etc/init.d/mysqld restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题总结（一）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F2017%2F07%2F31%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[1 Spring MVC的工作原理是怎样的？客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。 DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。在这个地方Spring会通过HandlerAdapter（一个适配器，它用统一的接口对各种Handler中的方法进行调用。）对该处理器进行封装。 Handler完成对用户请求的处理后，会返回一个ModelAndView（包含了数据模型以及相应的视图的信息）对象给DispatcherServlet。 DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。 2 什么是IoC和DI？DI是如何实现的？IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。 控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。 依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。 依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。 3 MyBatis中使用#和$书写占位符有什么区别？#将传入的数据都当成一个字符串，会对传入的数据自动加上引号； $将传入的数据直接显示生成在SQL中。 注意：使用$占位符可能会导致SQL注射攻击，能用#的地方就不要使用$，写order by子句的时候应该用$而不是#。 4 JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数; response：封装服务器对客户端的响应; pageContext：通过该对象可以获取其他对象; session：封装用户会话的对象; application：封装服务器运行环境的对象; out ：输出服务器响应的输出流对象; - config：Web应用的配置对象; - page：JSP页面本身（相当于Java程序中的这个）; exception：封装页面抛出异常的对象。 5 讲解JSP中的四种作用域答：JSP中的四种作用域包含page，request，session和application 具体来说： page代表与一个页面相关的对象和属性. request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件;需要在页面显示的临时数据可以置于此作用域. session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的会话中。 application是整个网络应用程序相关的对象和属性，它实质上是跨越整个网络应用程序，包括多个页面，请求 和会话的一个全局作用域。 6 你的项目中使用过哪些JSTL标签？答：项目中主要使用了JSTL的核心标签库，包括，，， 等，主要用于构造循环和分支结构以控制显示逻辑。 7 Jsp指令有那些？Include Taglib Page 8 会话跟踪技术有那些？Session Cookie 表单隐藏域 url重写 9 Session与cookie的区别？Session保存在服务端，cookie保存在客户端 Session保存是对象，cookie只能保存字符串 Session不能设置路径，cookie可以设置保存路径。 同一个网站不同网页的cookie可以保存到不通的路机构下，彼此是无法相互访问的。 Session在服务器关闭后会自动消失，cookie则不会。 10 创建socket通讯的步骤？ 服务器程序创建一个ServerSocket，然后再用accept方法等待客户来连接 客户端程序创建一个Socket并请求与服务器建立连接 服务器接收客户的连接请求,并创建一个新的Socket与该客户建立专线连接 刚才建立了连接的两个Socket在一个线程上对话 服务器开始等待新的连接请求 11 什么是事务？事务有那些特点？事务：单个逻辑单元执行的一系列操作，要么全部执行，要么全部不执行。 特点： 原子性（Atomicity）：事务中各元素不可分割，全部执行成功或者撤销所有的操作 一致性（Consistency）：事务完成后数据保持一致的状态 隔离性（Isolation）：事务是相对独立的，对某数据进行修改时，其他事务不变 持久性（Durability）：事务完成后对系统的影响是永久性的。 12 聚集索引与非聚集索引有什么区别？所有的索引都是为了更快地检索数据，索引存放在索引页中，数据存放在数据页中，索引以B（balance）树的形式存储 聚集索引：聚集索引用于决定数据表中的物理存储顺序，一张表最多有一个聚集索引。聚集索引的字段值尽量不能修改，因为修改后，因为修改后数据表的物理顺序需要重写排序。通常主键就是聚集索引 非聚集索引：非聚集索引的关键自是index，不会决定表的物理存储顺序，在一张表内最多可以有249个非聚集索引。 13 Java API解析xml主要有两种方式； Dom解析：一次性加载整个文档，生成树形结构。在生成的文档对象中，可以对节点进行增删改查的操作。当xml文本当较小的时候，可以使用dom解析。 Sax解析：基于事件的解析方式，解析速度比较快，解析的文档大小理论上是没有限制的。 还有一些开源的技术可以解析xml，dom4j或者jdom。 14 Sql中delete与truncate的区别 DELETE：选择性地删除数据，当删除整张表的数据时效率较低； truncate只能删除整张表的数据，但是效率高于使用DELETE语句；不能选择性地删除。当truncate执行删除之后，自动生成的主键值重新从默认值开始。 15 过滤器有哪些作用和用法？ 过滤器是一个驻留在服务器端的网络组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。 当网络容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。 在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。 常见的过滤器用途主要包括：对用户请求进行统一认证，对用户的访问请求进行记录和审核，对用户发送的数据进行过滤或替换，转换图象格式，对响应内容进行压缩以减少传输量，对请求或响应进行加解密处理，触发资源访问事件，对XML的输出应用XSLT等。 和过滤器相关的接口主要有：过滤器，一个FilterConfig和FilterChain。 16 监听器有哪些作用和用法？答：Java Web开发中的监听器（监听器）就是应用程序，会话，请求三个对象创建，销毁或者往其中添加修改删除属性时自动执行代码的功能组件， 如下所示：①ServletContextListener：对Servlet上下文的创建和销毁进行监听 ②ServletContextAttributeListener：监听Servlet上下文属性的添加，删除和替换 ③HttpSessionListener：对会话的创建和销毁进行监听。 补充：session的销毁有两种情况：1). session超时（可以在web.xml中通过/标签配置超时时间）； 2). 通过调用session对象的invalidate()方法使session失效。⑤HttpSessionAttributeListener：对会话对象中属性的添加，删除和替换进行监听⑤ServletRequestListener：对请求对象的初始化和销毁​​进行监听⑥ServletRequestAttributeListener：对请求对象属性的添加，删除和替换进行监听。 17 简述JVM内存分配 基本数据类型变量和对象的引用都是在栈分配的 堆内存用来存放由new创建的对象和数组 类变量(static修饰的变量)，程序在加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中 实例变量，当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的物理位置。实例变量的生命周期: 当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收名单中，但并不是马上就释放堆中内存。 局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放18 JVM内存模型 19 String对象的intern()是干什么的intern()方法会首先从常量池中查找是否存在该常量值, 如果常量池中不存在则先在常量池中创建, 如果已经存在则直接返回, 如:String s1=”aa”;String s2=s1.intern();System.out.print(s1==s2);//返回true 20 你对static了解多少 static成员变量是在类加载的时候生成的 static成员函数既可以通过类名直接调用，也可以通过对象名进行调用虚函数是C++中的，虚函数不可能是static的 static成员函数可以访问static成员变量]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
</search>

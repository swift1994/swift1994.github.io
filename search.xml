<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解Java线程池]]></title>
    <url>%2FJava%2F2017%2F09%2F19%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content type="text"><![CDATA[线程池的作用： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 常用线程池：ExecutorService是主要的实现类，其中常用的有Executors.newSingleThreadPool(), newFixedThreadPool(), newcachedTheadPool(), newScheduledThreadPool()。 线程池原理预先启动一些线程，线程无限循环从任务队列中获取一个任务进行执行，直到线程池被关闭。如果某个线程因为执行某个任务发生异常而终止，那么重新创建一个新的线程而已。如此反复。 ● step1、调用ThreadPoolExecutor的执行提交线程，首先检查CorePool，如果CorePool内的线程小于CorePoolSize，新创建线程执行任务 ● step2、如果当前CorePool内的线程大于等于CorePoolSize，那么将线程加入到BlockingQueue。 ● step3、如果不能加入BlockingQueue，在小于MaxPoolSize的情况下创建线程执行任务 ● step4。如果线程数大于等于MaxPoolSize，那么执行拒绝策略。 线程池的创建 worker：工作类，一个worker代表启动了一个线程，它启动后会循环执行workQueue里面的所有任务 1ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ● corePoolSize（线程池的基本大小）当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。 ● runnableTaskQueue（任务队列）用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级得无限阻塞队列。 ● maximumPoolSize（线程池最大大小）线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。 ● ThreadFactory用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置 更有意义的名字，Debug和定位问题时非常又帮助。 ● keepAliveTime（线程活动保持时间） 线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。 ● TimeUnit（线程活动保持时间的单位）可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。 RejectedExecutionHandler（饱和策略）当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略： CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。1.当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。 线程池任务submit及执行流程流程分析：线程池的主要工作流程如下图： 从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下： a.一个任务提交，如果线程池大小没达到corePoolSize，则每次都启动一个worker也就是一个线程来立即执行 b.如果来不及执行，则把多余的线程放到workQueue，等待已启动的worker来循环执行 c.如果队列workQueue都放满了还没有执行，则在maximumPoolSize下面启动新的worker来循环执行workQueue d.如果启动到maximumPoolSize还有任务进来，线程池已达到满负载，此时就执行任务拒绝RejectedExecutionHandler Java Code 线程池核心的代码 1234567891011121314151617181920212223241. // 流程就是：没达到corePoolSize，创建worker执行，达到corePoolSize加入workQueue// workQueue满了且在maximumPoolSize下，创建新worker，达到maximumPoolSize，执行rejectpublic void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // 1：poolSize达到corePoolSize，执行3把任务加入workQueue // 2：poolSize没达到，执行addIfUnderCorePoolSize()在corePoolSize内创建新worker立即执行任务 // 如果达到corePoolSize，则同上执行3 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; // 3:workQueue满了，执行5 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) &#123; // 4:如果线程池关闭，执行拒绝策略 // 如果poolSize==0，新启动一个线程执行队列内任务 ensureQueuedTaskHandled(command); &#125; // 5:在maximumPoolSize内创建新worker立即执行任务 // 如果达到maximumPoolSize，执行6拒绝策略 &#125; else if (!addIfUnderMaximumPoolSize(command)) // 6:拒绝策略 reject(command); // is shutdown or saturated &#125;&#125; 从上面代码可以看出，一个任务提交什么时候立即执行呢？ 1runState == RUNNING &amp;&amp; ( poolSize &lt; corePoolSize || (workQueue.isFull() &amp;&amp; poolSize &lt; maxnumPoolSize)) 向线程池提交任务1、我们可以使用execute提交的任务，但是execute方法没有返回值，所以无法判断任务知否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。 123456threadsPool.execute(new Runnable() &#123;@Overridepublic void run() &#123;// TODO Auto-generated method stub&#125;&#125;); 2、我们也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。 12345678910try &#123;Object s = future.get();&#125; catch (InterruptedException e) &#123;// 处理中断异常&#125; catch (ExecutionException e) &#123;// 处理无法执行任务异常&#125; finally &#123;// 关闭线程池executor.shutdown();&#125; 工作Worker的原理上面讲过线程池创建线程其实是委托给Worker这个对象完成的。worker会循环获取工作队列的任务来完成。线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点： 1234567891011121314public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; // getTask()是从workQueue里面阻塞获取任务，如果getTask()返回null则终结本线程 while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; // 走到这里代表这个worker或者说这个线程由于线程池关闭或超过aliveTime需要关闭了 workerDone(this); &#125;&#125; 线程的销毁keepAliveTime：代表的就是线程空闲后多久后销毁，线程的销毁是通过worker的getTask()来实现的。 一般来说，Worker会循环获取getTask()，如果getTask()返回null则工作线程worker终结，那我们再看看什么时候getTask()返回null 123456789101112131415161718192021222324252627282930Runnable getTask() &#123; for (;;) &#123; try &#123; int state = runState; if (state &gt; SHUTDOWN) return null; Runnable r; if (state == SHUTDOWN) // Help drain queue r = workQueue.poll(); else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) // 在poolSize大于corePoolSize或允许核心线程超时时 // 阻塞超时获取有可能获取到null，此时worker线程销毁 r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS); else r = workQueue.take(); if (r != null) return r; // 这里是是否运行worker线程销毁的判断 if (workerCanExit()) &#123; if (runState &gt;= SHUTDOWN) // STOP或TERMINATED状态，终止空闲worker interruptIdleWorkers(); return null; // 这里返回null，代表工作线程worker销毁 &#125; // 其他：retry，继续循环 &#125; catch (InterruptedException ie) &#123; // On interruption, re-check runState &#125; &#125;&#125; 线程池关闭平缓关闭 shutdown已经启动的任务全部执行完毕，同时不再接受新的任务 立即关闭 shutdownNow取消所有正在执行和未执行的任务shutdown的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。 只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。 线程池的监控通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用。 taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。 largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。 getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+getActiveCount：获取活动的线程数。 通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将一个文件的内容复制到另一个文件]]></title>
    <url>%2F%E7%AC%94%E8%AF%95%E9%A2%98%2F2017%2F09%2F14%2F%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD.html</url>
    <content type="text"><![CDATA[1. 使用FileStreams复制这是最经典的方式将一个文件的内容复制到另一个文件中。 使用FileInputStream读取文件A的字节，使用FileOutputStream写入到文件B。 这是第一个方法的代码: 1234567891011121314151617private static void copyFileUsingFileStreams(File source, File dest) throws IOException &#123; InputStream input = null; OutputStream output = null; try &#123; input = new FileInputStream(source); output = new FileOutputStream(dest); byte[] buf = new byte[1024]; int bytesRead; while ((bytesRead = input.read(buf)) &gt; 0) &#123; output.write(buf, 0, bytesRead); &#125; &#125; finally &#123; input.close(); output.close(); &#125;&#125; 正如你所看到的我们执行几个读和写操作try的数据,所以这应该是一个低效率的,下一个方法我们将看到新的方式。 2. 使用FileChannel复制Java NIO包括transferFrom方法,根据文档应该比文件流复制的速度更快。 这是第二种方法的代码: 123456789101112private static void copyFileUsingFileChannels(File source, File dest) throws IOException &#123; FileChannel inputChannel = null; FileChannel outputChannel = null; try &#123; inputChannel = new FileInputStream(source).getChannel(); outputChannel = new FileOutputStream(dest).getChannel(); outputChannel.transferFrom(inputChannel, 0, inputChannel.size()); &#125; finally &#123; inputChannel.close(); outputChannel.close(); &#125;&#125; 3. 使用Commons IO复制Apache Commons IO提供拷贝文件方法在其FileUtils类,可用于复制一个文件到另一个地方。它非常方便使用Apache Commons FileUtils类时,您已经使用您的项目。基本上,这个类使用Java NIO FileChannel内部。 这是第三种方法的代码: 1234private static void copyFileUsingApacheCommonsIO(File source, File dest) throws IOException &#123; FileUtils.copyFile(source, dest);&#125; 4. 使用Java7的Files类复制如果你有一些经验在Java 7中你可能会知道,可以使用复制方法的Files类文件,从一个文件复制到另一个文件。 这是第四个方法的代码: 1234private static void copyFileUsingJava7Files(File source, File dest) throws IOException &#123; Files.copy(source.toPath(), dest.toPath());&#125;]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建并运行java线程]]></title>
    <url>%2FJava%2F2017%2F09%2F13%2F%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8Cjava%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[编写线程运行时执行的代码有两种方式第一种是创建Thread子类的一个实例并重写run方法第二种是创建类的时候实现Runnable接口创建Thread的子类创建Thread子类的一个实例并重写run方法，run方法会在调用start()方法之后被执行。 12345public class MyThread extends Thread &#123; public void run()&#123; System.out.println(&quot;MyThread running&quot;); &#125;&#125; 可以用如下方式创建并运行上述Thread子类 12MyThread myThread = new MyThread();myTread.start(); 一旦线程启动后start方法就会立即返回，而不会等待到run方法执行完毕才返回。就好像run方法是在另外一个cpu上执行一样。当run方法执行后，将会打印出字符串MyThread running。 你也可以如下创建一个Thread的匿名子类： 123456Thread thread = new Thread()&#123; public void run()&#123; System.out.println(&quot;Thread Running&quot;); &#125;&#125;;thread.start(); 当新的线程的run方法执行以后，计算机将会打印出字符串”Thread Running”。 实现Runnable接口第二种编写线程执行代码的方式是新建一个实现了java.lang.Runnable接口的类的实例，实例中的方法可以被线程调用。下面给出例子： 12345public class MyRunnable implements Runnable &#123; public void run()&#123; System.out.println(&quot;MyRunnable running&quot;); &#125;&#125; 为了使线程能够执行run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。示例如下： 12Thread thread = new Thread(new MyRunnable());thread.start(); 当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。 同样，也可以创建一个实现了Runnable接口的匿名类，如下所示： 1234567Runnable myRunnable = new Runnable()&#123; public void run()&#123; System.out.println(&quot;Runnable running&quot;); &#125;&#125;Thread thread = new Thread(myRunnable);thread.start(); 创建子类还是实现Runnable接口？对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。就我个人意见，我更倾向于实现Runnable接口这种方法。 因为线程池可以有效的管理实现了Runnable接口的线程，如果线程池满了，新的线程就会排队等候执行，直到线程池空闲出来为止。而如果线程是通过实现Thread子类实现的，这将会复杂一些。 有时我们要同时融合实现Runnable接口和Thread子类两种方式。例如，实现了Thread子类的实例可以执行多个实现了Runnable接口的线程。一个典型的应用就是线程池。 常见错误：调用run()方法而非start()方法创建并运行一个线程所犯的常见错误是调用线程的run()方法而非start()方法， 12Thread newThread = new Thread(MyRunnable());newThread.run(); //should be start(); 起初你并不会感觉到有什么不妥，因为run()方法的确如你所愿的被调用了。但是，事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行run()方法，必须调用新线程的start方法。 线程名当创建一个线程的时候，可以给线程起一个名字。它有助于我们区分不同的线程。例如：如果有多个线程写入System.out，我们就能够通过线程名容易的找出是哪个线程正在输出。 1234MyRunnable runnable = new MyRunnable();Thread thread = new Thread(runnable, &quot;New Thread&quot;);thread.start();System.out.println(thread.getName()); 需要注意的是，因为MyRunnable并非Thread的子类，所以MyRunnable类并没有getName()方法。可以通过以下方式得到当前线程的引用: 1Thread.currentThread(); 因此，通过如下代码可以得到当前线程的名字： 1String threadName = Thread.currentThread().getName();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java内存管理]]></title>
    <url>%2FJava%2F2017%2F09%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[运行时数据区域 1 程序计数器PC程序计数器PC，当前线程所执行的字节码行号指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）。 2 虚拟机栈虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)执行的同时都会创建一个栈帧结构，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。栈帧(Stack Frame)结构栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机站的栈元素。见上图， 栈帧包括： 局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位。 操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配 动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。 ○ 前面的解析过程其实是静态解析； ○ 对于运行期转化为直接引用，称为动态解析。 方法返回地址 ○ 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者 ○ 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。 额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。异常(Exception)Java虚拟机规范规定该区域有两种异常：● StackOverFlowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出● OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出 3 本地方法栈本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。异常(Exception)：Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。 4 Java堆Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。 从内存回收角度，Java堆被分为新生代和老年代；这样划分的好处是为了更快的回收内存； 从内存分配角度，Java堆可以划分出线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)；这样划分的好处是为了更快的分配内存；对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下： 对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。 另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存.异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 5 方法区方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。GC在该区域出现的比较少。异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 运行时常量池运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。 字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。 符号引用：编译语言层面的概念，包括以下3类： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 但是该区域不会抛出OutOfMemoryError异常。 详情请看《深入理解JVM虚拟机》第二章38页]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet的生命周期及实现原理]]></title>
    <url>%2FServlet%2F2017%2F09%2F09%2FServlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[生命周期分为三个阶段 初始化阶段 调用init()方法 响应客户请求阶段 调用service()方法 终止阶段 调用destroy()方法 1、Servlet初始化阶段 在下列时刻Servlet容器装载Servlet： Servlet容器启动时自动装载某些Servlet，实现它只需要在web.XML文件中的之间添加如下代码： 1&lt;loadon-startup&gt;1&lt;/loadon-startup&gt; 在Servlet容器启动后，客户首次向Servlet发送请求 Servlet类文件被更新后，重新装载Servlet Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。 2、Servlet响应请求阶段 对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。 对于Tomcat来说，它会将传递过来的参数放在一个Hashtable中，该Hashtable的定义是 1private Hashtable&lt;String String[]&gt; paramHashStringArray = new Hashtable&lt;String String[]&gt;(); 这是一个String–&gt;String[]的键值映射。 HashMap线程不安全的，Hashtable线程安全。 3、Servlet终止阶段 当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。 Servlet工作原理 首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。 在Servlet接口和GenericServlet中是没有doGet,doPost等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。 每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。 Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest,ServletResponse强转为HttpRequest和HttpResponse。 12345678910111213141516public void service(ServletRequest req,ServletResponse res) throws ServletException,IOException&#123; HttpRequest request; HttpResponse response; try &#123; req = (HttpRequest)request; res = (HttpResponse)response; &#125;catch(ClassCastException e) &#123; throw new ServletException(&quot;non-HTTP request response&quot;); &#125; service(request,response);&#125; 代码的最后调用了HTTPServlet自己的service(request,response)方法，然后根据请求去调用对应的doXXX方法，因为HttpServlet中的doXXX方法都是返回错误信息，所以需要我们在自定义的Servlet中override这些方法。 1234567891011121314protected void doGet(HttpServletRequest res,HttpServletResponse resp) throws ServletException,IOException&#123; String protocol = req.getProtocol(); String msg = IStrings.getString(&quot;http.method_get_not_supported&quot;); if(protocol.equals(&quot;1.1&quot;)) &#123; resp.sendError(HttpServletResponse.SC.METHOD.NOT.ALLOWED,msg); &#125; esle &#123; resp.sendError(HttpServletResponse.SC_BAD_REQUEST,msg); &#125;&#125;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解HashMap]]></title>
    <url>%2FJava%2F2017%2F09%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap.html</url>
    <content type="text"><![CDATA[HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 1、hashmap的数据结构要知道hashmap是什么，首先要搞清楚它的数据结构，在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素实际上是一个链表）。 从图中我们可以看到一个hashmap就是一个数组结构，当新建一个hashmap的时候，就会初始化一个数组。我们来看看java代码： Java代码 123451. /** 2. * The table, resized as necessary. Length MUST Always be a power of two. 3. * FIXME 这里需要注意这句话，至于原因后面会讲到 4. */ 5. transient Entry[] table; Java代码 12345671. static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; 2. final K key; 3. V value; 4. final int hash; 5. Entry&lt;K,V&gt; next; 6. .......... 7. &#125; 上面的Entry就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的，但是理想总是美好的，现实总是有困难需要我们去克服，哈哈~ 2、hash算法我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的， 12345Java代码 1. static int indexFor(int h, int length) &#123; 2. return h &amp; (length-1); 3. &#125; 首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。 说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。 所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)： 123456Java代码 1. // Find a power of 2 &gt;= initialCapacity 2. int capacity = 1; 3. while (capacity &lt; initialCapacity) 4. capacity &lt;&lt;= 1; 3、hashmap的resize当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.751000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 4、key的hashcode与equals方法改写在第一部分hashmap的数据结构中，annegu就写了get方法的过程：首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。 Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。在改写equals方法的时候，需要满足以下三点： (1) 自反性：就是说a.equals(a)必须为true。 (2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。 (3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。 总结： 本文主要描述了HashMap的结构，和hashmap中hash函数的实现，以及该实现的特性，同时描述了hashmap中resize带来性能消耗的根本原因，以及将普通的域模型对象作为key的基本要求。尤其是hash函数的实现，可以说是整个HashMap的精髓所在，只有真正理解了这个hash函数，才可以说对HashMap有了一定的理解。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ArrayList]]></title>
    <url>%2FJava%2F2017%2F09%2F05%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ArrayList.html</url>
    <content type="text"><![CDATA[ArrayList概述 ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。 每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。 注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。 ArrayList的实现 对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码 底层使用数组实现： Java代码 private transient Object[] elementData; 构造方法： ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。 Java代码 1. public ArrayList() { 2. this(10); 3. } 4. 5. public ArrayList(int initialCapacity) { 6. super(); 7. if (initialCapacity &lt; 0) 8. throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); 9. this.elementData = new Object[initialCapacity]; 10. } 11. 12. public ArrayList(Collection&lt;? extends E&gt; c) { 13. elementData = c.toArray(); 14. size = elementData.length; 15. // c.toArray might (incorrectly) not return Object[] (see 6260652) 16. if (elementData.getClass() != Object[].class) 17. elementData = Arrays.copyOf(elementData, size, Object[].class); 18. } 存储： ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解： Java代码 1. // 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。 2. public E set(int index, E element) { 3. RangeCheck(index); 4. 5. E oldValue = (E) elementData[index]; 6. elementData[index] = element; 7. return oldValue; 8. } Java代码 1. // 将指定的元素添加到此列表的尾部。 2. public boolean add(E e) { 3. ensureCapacity(size + 1); 4. elementData[size++] = e; 5. return true; 6. } Java代码 1. // 将指定的元素插入此列表中的指定位置。 2. // 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。 3. public void add(int index, E element) { 4. if (index &gt; size || index &lt; 0) 5. throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size); 6. // 如果数组长度不足，将进行扩容。 7. ensureCapacity(size+1); // Increments modCount!! 8. // 将 elementData中从Index位置开始、长度为size-index的元素， 9. // 拷贝到从下标为index+1位置开始的新的elementData数组中 10. // 即将当前位于该位置的元素以及所有后续元素右移一个位置。 11. System.arraycopy(elementData, index, elementData, index + 1, size - index); 12. elementData[index] = element; 13. size++; 14. } Java代码 1. // 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。 2. public boolean addAll(Collection&lt;? extends E&gt; c) { 3. Object[] a = c.toArray(); 4. int numNew = a.length; 5. ensureCapacity(size + numNew); // Increments modCount 6. System.arraycopy(a, 0, elementData, size, numNew); 7. size += numNew; 8. return numNew != 0; 9. } Java代码 1. // 从指定的位置开始，将指定collection中的所有元素插入到此列表中。 2. public boolean addAll(int index, Collection&lt;? extends E&gt; c) { 3. if (index &gt; size || index &lt; 0) 4. throw new IndexOutOfBoundsException( 5. &quot;Index: &quot; + index + &quot;, Size: &quot; + size); 6. 7. Object[] a = c.toArray(); 8. int numNew = a.length; 9. ensureCapacity(size + numNew); // Increments modCount 10. 11. int numMoved = size - index; 12. if (numMoved &gt; 0) 13. System.arraycopy(elementData, index, elementData, index + numNew, numMoved); 14. 15. System.arraycopy(a, 0, elementData, index, numNew); 16. size += numNew; 17. return numNew != 0; 18. } 4) 读取： Java代码 1. // 返回此列表中指定位置上的元素。 2. public E get(int index) { 3. RangeCheck(index); 4. 5. return (E) elementData[index]; 6. } 删除： ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：Java代码 1. // 移除此列表中指定位置上的元素。 2. public E remove(int index) { 3. RangeCheck(index); 4. 5. modCount++; 6. E oldValue = (E) elementData[index]; 7. 8. int numMoved = size - index - 1; 9. if (numMoved &gt; 0) 10. System.arraycopy(elementData, index+1, elementData, index, numMoved); 11. elementData[--size] = null; // Let gc do its work 12. 13. return oldValue; 14. } Java代码 1. // 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。 2. public boolean remove(Object o) { 3. // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。 4. if (o == null) { 5. for (int index = 0; index &lt; size; index++) 6. if (elementData[index] == null) { 7. // 类似remove(int index)，移除列表中指定位置上的元素。 8. fastRemove(index); 9. return true; 10. } 11. } else { 12. for (int index = 0; index &lt; size; index++) 13. if (o.equals(elementData[index])) { 14. fastRemove(index); 15. return true; 16. } 17. } 18. return false; 19. } 注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。 调整数组容量：从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。 Java代码 public void ensureCapacity(int minCapacity) { Count++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } } 从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。 ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：Java代码 1. public void trimToSize() { 2. modCount++; 3. int oldCapacity = elementData.length; 4. if (size &lt; oldCapacity) { 5. elementData = Arrays.copyOf(elementData, size); 6. } 7. } Fail-Fast机制：ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考我之前的文章深入Java集合学习系列：HashMap的实现原理 中的Fail-Fast机制。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的性能和伸缩性优化]]></title>
    <url>%2FMySQL%2F2017%2F08%2F01%2FMySQL%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E4%BC%B8%E7%BC%A9%E6%80%A7%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[1、选择 InnoDB 作为存储引擎 大型产品的数据库对于可靠性和并发性的要求较高，InnoDB 作为默认的 MySQL 存储引擎，相对于 MyISAM 来说是个更佳的选择。 2、优化数据库结构 组织数据库的 schema、表和字段以降低 I/O 的开销，将相关项保存在一起，并提前规划，以便随着数据量的增长，性能可以保持较高的水平。 设计数据表应尽量使其占用的空间最小化，表的主键应尽可能短。 对于 InnoDB 表，主键所在的列在每个辅助索引条目中都是可复制的，因此如果有很多辅助索引，那么一个短的主键可以节省大量空间。 仅创建你需要改进查询性能的索引。索引有助于检索，但是会增加插入和更新操作的执行时间。 3、InnoDB 的 Change Buffering 特性 InnoDB 提供了 change buffering 的配置，可减少维护辅助索引所需的磁盘 I/O。大规模的数据库可能会遇到大量的表操作和大量的 I/O，以保证辅助索引保持最新。当相关页面不在缓冲池里面时，InnoDB 的 change buffer 将会更改缓存到辅助索引条目，从而避免因不能立即从磁盘读取页面而导致耗时的 I/O 操作。当页面被加载到缓冲池时，缓冲的更改将被合并，更新的页面之后会刷新到磁盘。这样做可提高性能，适用于 MySQL 5.5 及更高版本。 4、InnoDB 页面压缩 InnoDB 支持对表进行页面级的压缩。当写入数据页的时候，会有特定的压缩算法对其进行压缩。压缩后的数据会写入磁盘，其打孔机制会释放页面末尾的空块。如果压缩失败，数据会按原样写入。表和索引都会被压缩，因为索引通常是数据库总大小中占比很大的一部分，压缩可以显著节约内存，I/O 或处理时间，这样就达到了提高性能和伸缩性的目的。它还可以减少内存和磁盘之间传输的数据量。MySQL 5.1 及更高版本支持该功能。 注意，页面压缩并不能支持共享表空间中的表。共享表空间包括系统表空间、临时表空间和常规表空间。 5、使用批量数据导入在主键上使用已排序的数据源进行批量数据的导入可加快数据插入的过程。否则，可能需要在其他行之间插入行以维护排序，这会导致磁盘 I/O 变高，进而影响性能，增加页的拆分。关闭自动提交的模式也是有好处的，因为它会为每个插入执行日志刷新到磁盘。在批量插入期间临时转移唯一键和外键检查也可显著降低磁盘 I/O。对于新建的表，最好的做法是在批量导入后创建外键/唯一键约束。 6、SQL 语句优化 为了提升查询的速度，可以为 WHERE 字句中使用的列添加索引。此外，不要将主键索引用于太多或太长的列，因为这些列值在辅助索引进行复制的时候会增加读取所需要的 I/O 资源并占用缓存。 如果索引包含了不必要的数据，通过 I/O 读取这些数据并进行缓存就会减弱服务器的性能和伸缩性。也不要为不必要的列使用唯一键索引，因为它会禁用 change buffering。应该使用常规索引代替。 减少和隔离需要耗费大量时间的函数调用。 尽可能的减少查询中的全表扫描次数。 调整缓存区域的大小和属性，比如 InnoDB 缓冲池，MySQL 查询缓存等，这样会通过从内存而非从硬盘获取数据而让重复的查询变得更快。 7、优化存储结构 对于大型的表，或者包含大量重复文本或数值数据的表，应该考虑使用 COMPRESSED(压缩的) 行格式。这样只需要较少的 I/O 就可以把数据取到缓冲池，或执行全表扫描。 一旦你的数据达到稳定的大小，或者增长的表增加了几十或几百兆字节，就应该考虑使用 OPTIMIZE TABLE 语句重新组织表并压缩浪费的空间。对重新组织后的表进行全表扫描所需要的 I/O 会更少。 8、优化 InnoDB 磁盘 I/O 增加 InnoDB 缓冲池大小可以让查询从缓冲池访问而不是通过磁盘 I/O 访问。通过调整系统变量 innodb_flush_method 来调整清除缓冲的指标使其达到最佳水平。 使用其它存储设备配置 RAID 9、MySQL 的内存分配 在为 MySQL 分配足够的内存之前，请考虑不同领域对 MySQL 的内存需求。 要考虑的关键领域是：并发连接 —— 对于大量并发连接，排序和临时表将需要大量内存。在撰写本文时，对于处理 3000+ 并发连接的数据库，16GB 到 32GB的 RAM 是足够的。 内存碎片可以消耗大约 10％ 或更多的内存。像 innodb_buffer_pool_size、key_buffer_size、query_cache_size 等缓存和缓冲区要消耗大约 80％ 的已分配内存。 10、日常维护 定期检查慢的查询日志并优化查询机制以有效使用缓存来减少磁盘 I/O。优化它们，以扫描最少的行数，而不是进行全表扫描。 其他可以帮助 DBA 检查和分析性能的日志包括：错误日志、常规查询日志、二进制日志、DDL日志（元数据日志）。 定期刷新缓存和缓冲区以降低碎片化。使用 OPTIMIZE TABLE 语句重新组织表并压缩任何可能被浪费的空间。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centOS环境搭建（一）]]></title>
    <url>%2FLinux%2F2017%2F07%2F31%2Flinux%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[阿里云ECS服务器,centos6.5安装jdk，mysql，tomcat现在很多博客上都有很多莫名的错误，我试着总结以下吧，希望减少时间的浪费，说实话我搭建了1天多才完全弄好，原因就是很多文档博客都不缜密，会出现很多错 前提下载安装xshell（具体如何是使用xshell请自行Google）和xftp 1 部署jdk查看系统是否安装了jdk [root@localhost ~]# java -version或者 [root@localhost ~]#rpm -qa |grep java 出现或者不出现以下内容： java version “1.7.0_24”OpenJDK Runtime Environment (build 1.7.0_24-b18)OpenJDK HotSpot(TM) Client VM (build 24.45-b08, mixed mode, sharing) 进一步查看JDK信息：[root@localhost ~]# rpm -qa | grep javatzdata-java-2012c-1.el6.noarchjava-1.7.0-openjdk-1.7.0.45-1.45.1.11.1.el6.x86_64 卸载OpenJDK，执行以下操作：[root@localhost ~]# rpm -e –nodeps tzdata-java-2012c-1.el6.noarch（解压jdk）[root@localhost ~]# rpm -e –nodeps java-1.7.0-openjdk-1.7.0.45-1.45.1.11.1.el6.x86_64 若出现以上以上情况，按照以上步骤操作完后，用xftp上传jdk-7-linux-i586.rpm或者jdk-8u25-linux-x64.tar.gz（具体jdk版本看你自己选择，在Oracle官网上下载 ）到xftp上的/usr/local 2 安装jdk（JDK默认安装在/usr/java中）：[root@localhost ~]#cd /usr/local (cd 空格后路径是你刚刚上传到xftp的路径，不要搞错了，我上是传到/usr/local，这一点很多博客文档都没说清楚，导致很多初学者会具体操作时出错)[root@localhost ckb]# rpm -ivh jdk-7-linux-i586.rpm或者[root@localhost ckb]#tar –zxvf jdk-8u25-linux-x64.tar.gz 3 验证安装执行以下操作，查看信息是否正常： [root@localhost bin]# java [root@localhost bin]# javac [root@localhost bin]# java -version java version “1.7.0_45”Java(TM) SE Runtime Environment (build 1.7.0_45-b18)Java HotSpot(TM) Client VM (build 24.45-b08, mixed mode, sharing) 4 配置环境变量我的机器安装完jdk-7-linux-i586.rpm后不用配置环境变量也可以正常执行javac、java –version操作，因此我没有进行JDK环境变量的配置。 但是为了以后的不适之需，这里还是记录一下怎么进行配置，操作如下：修改系统环境变量文件vi + /etc/profile执行之后 按”i”建，INSERT出现表示可以编辑向文件里面追加以下内容： 在光标处添加JAVA_HOME=/usr/java/jdk1.7.0_45 JRE_HOME=/usr/java/jdk1.7.0_45/jre PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin CLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH（然后按Esc退出，”:”符+ wq保存并退出） 使修改生效[root@localhost ~]# source /etc/profile（使修改立即生效） [root@localhost ~]# echo $PATH（查看PATH值） 查看系统环境状态 [root@localhost ~]# echo $PATH/usr/lib/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/java/jdk1.7.0_45/bin:/usr/java/jdk1.7.0_45/jre/bin:/home/ckb/bin 二、部署tomcat(与配置jdk类似)在tomcat官网上下载 apache-tomcat-8.0.15.tar.gz并上传到/usr/local [root@localhost ~]#cd /usr/local [root@localhost local]#tar –zxvf apache-tomcat-8.0.15.tar.gz 初始化配置：[root@localhost ~]#vi catalina.sh//设置环境变量 末行添加：JAVA_HOME=/usr/javaCATALINA_HOME=/usr/local/apache-tomcat-8.0.15export JAVA_HOME PATH（然后按Esc退出，”:”符+ wq保存并退出） 启动tomcat进入tomcat/bin目录 [root@localhost ~]#cd /usr/local/apache-tomcat-8.0.15/lib [root@localhost bin] # ./startup.sh[root@localhost bin] # ./shutdown.sh //关闭tomcat 启动之后就可以在浏览器输入你的公网ip:8080（tomcat默认端口），看到tomcat页面。 三 配置mysql（我的这里参考了http://blog.csdn.net/sapce_fish/article/details/51619830?locationNum=12&amp;fps=1这篇博客，版本为mysql.x86_64 5.1.73-7.el6，当然你也可以安装其他版本） 安装mysql；==特别注意==：网上很多安装mysql的文章，都是不行的！！！！ #我喜欢在home目录操作命令cd /home #查看所有以mysql开头的软件 yum list mysql* #安装mysql yum install mysql-server* -y #启动mysql /etc/init.d/mysqld start #设定mysql自动启动，我亲自重启了ECS，确实ok chkconfig mysqld on #复制mysql的配置文件到etc目录，提示是否覆盖，选择ycp /usr/share/mysql/my-medium.cnf /etc/my.cnf #重新设定mysql密码，默认密码是【空】，输入新密码，注意提问，是否删除匿名账户？【y】 是否禁止远程登录？【n】是否移除test数据库?【y】是否重载权限文件【y】mysql_secure_installation #重启mysql，此时用本机Navicat Premium还是连不上mysql的！/etc/init.d/mysqld restart #用命令访问mysqlmysql -u root -p #使用mysql数据库use mysql; #查询当前用户情况，显示有3条记录，127.0.0.1；localhost；izxxxxxxxdz；其中最后这个是ECS主机名 select host, user from user; #把localhost这条记录的host改为 %； 意思是root可以由任何主机登录mysql，网上很多写法，都没有and host=’localhost’这个条件，经常报错。update user set host = ‘%’ where user = ‘root’ and host=’localhost’; #再次查询，可以看到host有3个；%；127.0.0.1；izxxxxxxxdz；其实user表的主键是user字段和host字段的联合主键。select host, user from user; #保险起见，重启mysql，Navicat Premium连接正常！万岁！/etc/init.d/mysqld restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux搭建</tag>
      </tags>
  </entry>
</search>
